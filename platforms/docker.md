# Working with Docker

This document provides guidelines and best practices for AI agents working with Docker. Docker is a fundamental tool for creating consistent, isolated, and portable development and production environments.

## 1. Core Concepts

A solid understanding of Docker's core concepts is essential.

- **Images**: A read-only template with instructions for creating a Docker container. Images are the blueprints of your application. They are built from a `Dockerfile`.
- **Containers**: A runnable instance of an image. You can create, start, stop, move, or delete a container. Containers are isolated from one another and from the host machine.
- **Dockerfile**: A text document that contains all the commands a user could call on the command line to assemble an image. `docker build` uses this file to create an image.
- **Volumes**: The preferred mechanism for persisting data generated by and used by Docker containers. While bind mounts are dependent on the directory structure of the host machine, volumes are completely managed by Docker.
- **Docker Hub / Registries**: A registry of Docker images. Docker Hub is the default public registry. You can pull images from a registry and push your own images to it.
- **Docker Compose**: A tool for defining and running multi-container Docker applications. It uses a YAML file (`docker-compose.yml`) to configure the application's services.

## 2. Dockerfile Best Practices

Writing a clean, efficient, and secure `Dockerfile` is critical.

- **Use a `.dockerignore` file**: Exclude files and directories that are not necessary for the build, such as `.git`, `node_modules`, and temporary files. This reduces the build context size and improves build performance.
- **Use Multi-Stage Builds**: Use multi-stage builds to separate the build environment from the final runtime environment. This dramatically reduces the size of your final image by excluding build-time dependencies and tools.

  ```dockerfile
  # Build stage
  FROM node:18 as builder
  WORKDIR /app
  COPY package.json .
  RUN npm install
  COPY . .
  RUN npm run build

  # Final stage
  FROM nginx:stable-alpine
  COPY --from=builder /app/build /usr/share/nginx/html
  EXPOSE 80
  CMD ["nginx", "-g", "daemon off;"]
  ```

- **Choose Minimal Base Images**: Start with a minimal base image, like `alpine`, to reduce the image size and attack surface.
- **Don't Install Unnecessary Packages**: Avoid installing debugging tools or other packages that are not needed in the final image.
- **Combine `RUN` instructions**: Chain `RUN` commands using `&&` to reduce the number of layers in your image. Clean up temporary files in the same layer.

  ```dockerfile
  RUN apt-get update && apt-get install -y \
      package-one \
      package-two \
      && rm -rf /var/lib/apt/lists/*
  ```

- **Leverage Build Cache**: Order your `Dockerfile` instructions from least to most frequently changing. `COPY package.json` and `RUN npm install` should come before `COPY . .` so that you don't have to re-install dependencies every time a source file changes.
- **Run as a Non-Root User**: Create a non-root user and use the `USER` instruction to run your application. This is a crucial security best practice.

  ```dockerfile
  RUN addgroup -S appgroup && adduser -S appuser -G appgroup
  USER appuser
  ```

## 3. Essential CLI Commands

You will frequently interact with the Docker daemon via the CLI.

### Single Container Management

- `docker build -t <image-name>:<tag> .`: Build an image from a Dockerfile.
- `docker run [OPTIONS] <image-name>`: Run a container from an image.
  - `-d`: Detached mode (run in the background).
  - `-p <host-port>:<container-port>`: Map a port.
  - `--rm`: Automatically remove the container when it exits.
  - `-v <volume-name>:<container-path>`: Mount a volume.
  - `--name <container-name>`: Assign a name to the container.
- `docker ps`: List running containers. (`-a` to show all).
- `docker stop <container-id|name>`: Stop a running container.
- `docker rm <container-id|name>`: Remove a stopped container.
- `docker logs <container-id|name>`: View the logs of a container.
- `docker exec -it <container-id|name> <command>`: Execute a command in a running container (e.g., `bash`).
- `docker images`: List all images on the system.
- `docker rmi <image-id>`: Remove an image.
- `docker pull <image-name>:<tag>`: Pull an image from a registry.
- `docker push <image-name>:<tag>`: Push an image to a registry.

### Multi-Container Management (Docker Compose)

- `docker-compose up`: Build, (re)create, start, and attach to containers for a service. Use `-d` to run in detached mode.
- `docker-compose down`: Stop and remove containers, networks, images, and volumes. Use `-v` to remove named volumes.
- `docker-compose ps`: List containers.
- `docker-compose logs`: View logs from services.
- `docker-compose build`: Build or rebuild services.
- `docker-compose exec <service-name> <command>`: Execute a command in a running service.

## 4. Security Best Practices

- **Principle of Least Privilege**:
  - Always run containers as a non-root user (`USER` instruction).
  - Use `COPY` instead of `ADD` where possible, as `ADD` can have unexpected behavior (e.g., auto-extracting tarballs).
- **Reduce Attack Surface**:
  - Use minimal base images.
  - Don't install unnecessary packages.
  - Use multi-stage builds to discard build tools.
- **Scan for Vulnerabilities**: Use tools like Docker Scout, Trivy, or Snyk to scan your images for known vulnerabilities.
- **Manage Secrets Securely**:
  - Do not copy secrets (API keys, passwords) directly into your `Dockerfile`.
  - Use build-time secrets (`--secret`) or runtime environment variables/Docker secrets to handle sensitive data.
- **Prevent Privilege Escalation**: Run containers with `--security-opt=no-new-privileges` to prevent processes from gaining new privileges.
